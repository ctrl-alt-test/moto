vec4 splineAABB;
vec4 splineSegmentAABBs[SPLINE_SIZE / 2];
float splineSegmentDistances[SPLINE_SIZE / 2];


// Piece of code copy-pasted from:
// https://www.shadertoy.com/view/NltBRB
// Credit: MMatteini

void ComputeBezierSegmentsLengthAndAABB()
{
    float splineLength = 0.0;
    splineAABB = vec4(INF, INF, -INF, -INF);

    for (int i = ZERO(iTime); i < SPLINE_SIZE - 1; i += 2)
    {
        vec2 A = spline[i + 0];
        vec2 B = spline[i + 1];
        vec2 C = spline[i + 2];
        float segmentLength = BezierCurveLengthAt(A, B, C, 1.0);
        splineSegmentDistances[i / 2] = splineLength;
        splineLength += segmentLength;

        vec4 AABB = BezierAABB(A, B, C);
        splineSegmentAABBs[i / 2] = AABB;
        splineAABB.xy = min(splineAABB.xy, AABB.xy);
        splineAABB.zw = max(splineAABB.zw, AABB.zw);
    }
}

// Decompose a give location into its distance from the closest point on the spline. 
// and the length of the spline up to that point.
// Returns a vector where:
// X = signed distance from the spline
// Y = spline parameter t in the Bezier segment [0; 1]
// Z = spline length at the closest point
// W = spline segment index
//
// To get t of the entire spline:
// (Y + 0.5 * W) / float(SPLINE_SIZE)
//
vec4 ToSplineLocalSpace(vec2 p, float splineWidth)
{
    vec4 splineUV = vec4(INF, 0, 0, 0);

    if (DistanceFromAABB(p, splineAABB) > splineWidth)
    {
        return splineUV;
    }

    // For each bezier segment
    for (int i = ZERO(iTime); i < SPLINE_SIZE - 1; i += 2)
    {
        vec2 A = spline[i + 0];
        vec2 B = spline[i + 1];
        vec2 C = spline[i + 2];

        if (DistanceFromAABB(p, BezierAABB(A, B, C)) > splineWidth)
        {
            continue;
        }

        // This is to prevent 3 colinear points, but there should be better solution to it.
        B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C))); 
        // Current bezier curve SDF
        vec2 bezierSDF = BezierSDF(A, B, C, p);

        if (abs(bezierSDF.x) < abs(splineUV.x))
        {
            float lengthInSegment = BezierCurveLengthAt(A, B, C, clamp(bezierSDF.y, 0., 1.));
            float lengthInSpline = splineSegmentDistances[i / 2] + lengthInSegment;
            splineUV = vec4(
                bezierSDF.x,
                clamp(bezierSDF.y, 0., 1.),
                lengthInSpline,
                float(i));
        }
    }

    return splineUV;
}

// Generated by ChatGPT.
vec2 GetPositionOnCurve(float t)
{
    // Total spline length
    float totalLength = splineSegmentDistances[SPLINE_SIZE / 2 - 1];
    
    // Desired length along the spline for the given t
    float targetLength = t * totalLength;
    
    // Find the segment corresponding to this target length
    int segmentIndex = 0;
    for (int i = ZERO(iTime); i < SPLINE_SIZE / 2 - 1; ++i) {
        if (splineSegmentDistances[i] <= targetLength && splineSegmentDistances[i + 1] > targetLength) {
            segmentIndex = i;
            break;
        }
    }
    
    // Calculate how far along the segment we are
    float segmentStartLength = splineSegmentDistances[segmentIndex];
    float segmentEndLength = splineSegmentDistances[segmentIndex + 1];
    float segmentLength = segmentEndLength - segmentStartLength;
    float segmentT = (targetLength - segmentStartLength) / segmentLength;
    
    // Get the control points of the segment
    vec2 A = spline[segmentIndex * 2];
    vec2 B = spline[segmentIndex * 2 + 1];
    vec2 C = spline[segmentIndex * 2 + 2];

    return Bezier(A, B, C, segmentT);
}

//
// If you have a splineUV, call:
// GetPositionOnSpline(splineUV.yw)
//
// This function does the same as the ChatGPT one, but without the for loop.
//
vec2 GetPositionOnSpline(vec2 spline_t_and_index)
{
    float t = spline_t_and_index.x;
    int i = int(spline_t_and_index.y);
    vec2 A = spline[i + 0];
    vec2 B = spline[i + 1];
    vec2 C = spline[i + 2];

    return Bezier(A, B, C, t);
}

// x: actual width
// y: width + transition
// z: max width
vec3 roadWidthInMeters = vec3(4.0, 8.0, 8.0);
const float laneWidth = 3.5;

float roadMarkings(vec2 uv, float width, vec2 params)
{
    // Total interval, line length
    vec2 t1  = vec2(26.0 / 2.0, 3.0);
    vec2 t1b = vec2(26.0 / 4.0, 1.5);
    vec2 t2  = vec2(26.0 / 4.0, 3.0);
    vec2 t3  = vec2(26.0 / 6.0, 3.0);
    vec2 t3b = vec2(26.0 / 1.0, 20.0);
    vec2 continuous = vec2(100.0, 100.0);

    vec2 separationLineParams = t1;
    if (params.x > 0.25) separationLineParams = t1b;
    if (params.x > 0.50) separationLineParams = t3;
    if (params.x > 0.75) separationLineParams = continuous;

    vec2 sideLineParams = t2;
    if (width > 4.0) sideLineParams = t3b;

    float tileY = uv.y - floor(clamp(uv.y, 3.5-width, width) / 3.5) * 3.5;
    vec2 separationTileUV = vec2(fract(uv.x / separationLineParams.x) * separationLineParams.x, tileY);
    vec2 sideTileUV = vec2(fract((uv.x + 0.4) / sideLineParams.x) * sideLineParams.x, uv.y);

    float sideLine1 = Box2(sideTileUV - vec2(0.5 * sideLineParams.y, width), vec2(0.5 * sideLineParams.y, 0.10), 0.03);
    float sideLine2 = Box2(sideTileUV - vec2(0.5 * sideLineParams.y, -width), vec2(0.5 * sideLineParams.y, 0.10), 0.03);

    float separationLine1 = Box2(separationTileUV - vec2(0.5 * separationLineParams.y, 0.0), vec2(0.5 * separationLineParams.y, 0.10), 0.01);

    float pattern = min(min(sideLine1, sideLine2), separationLine1);

    return 1.-smoothstep(-0.01, 0.01, pattern);
}

material roadMaterial(vec2 uv, float width, vec2 params)
{
    vec2 laneUV = uv / laneWidth;

    float tireTrails = sin((laneUV.x-0.125) * 4. * PI) * 0.5 + 0.5;
    tireTrails = mix(tireTrails, smoothstep(0., 1., tireTrails), 0.25);

    float largeScaleNoise = smoothstep(-0.25, 1., fBm(laneUV * vec2(15., 0.1), 2, .7, .4));
    tireTrails = mix(tireTrails, largeScaleNoise, 0.2);

    float highFreqNoise = fBm(laneUV * vec2(150., 6.), 1, 1., 1.);
    tireTrails = mix(tireTrails, highFreqNoise, 0.1);

    float roughness = mix(0.8, 0.4, tireTrails);
    vec3 color = vec3(mix(vec3(0.11, 0.105, 0.1), vec3(0.15), tireTrails));


    float paint = roadMarkings(uv.yx, width, params);
    color = mix(color, vec3(0.5), paint);
    roughness = mix(roughness, 0.7, paint);

    // DEBUG --------
    /*
    vec2 marks = abs(fract(laneUV) * 2. - 1.);
    vec2 dmarks = fwidth(marks);
    marks = smoothstep(-dmarks, dmarks, marks - 0.99);
    vec3 debugUV = vec3(laneUV, 0.);
    debugUV = fract(debugUV);
    debugUV = clamp(debugUV, 0., 1.);
    debugUV = mix(debugUV * 0.5, vec3(1.), max(marks.x, marks.y));
    if (laneUV.x < 0.)
    {
        color = debugUV;
    }
    else
    {
        color = mix(color, vec3(1.), marks.x);
    }
    */
    // --------------

    return material(MATERIAL_TYPE_DIELECTRIC, color, roughness);
}

const float terrain_fBm_weight_param = 0.6;
const float terrain_fBm_frequency_param = 0.5;

float smoothTerrainHeight(vec2 p)
{
    float hillHeightInMeters = 200.;
    float hillLengthInMeters = 2000.;

    return 0.5 * hillHeightInMeters * fBm(p * 2. / hillLengthInMeters, 3, terrain_fBm_weight_param, terrain_fBm_frequency_param);
}

float terrainDetailHeight(vec2 p)
{
    float detailHeightInMeters = 1.;
    float detailLengthInMeters = 100.;

    return 0.5 * detailHeightInMeters * fBm(p * 2. / detailLengthInMeters, 1, terrain_fBm_weight_param, terrain_fBm_frequency_param);
}

vec2 roadSideItems(vec4 splineUV, float relativeHeight) {
    vec3 pRoad = vec3(abs(splineUV.x), relativeHeight, splineUV.z);

	// Traffic barrier
    vec3 pObj = vec3(pRoad.x - 4.2, pRoad.y - 0.8, 0.);
    float len = Box3(pObj, vec3(0.1, 0.2, 0.1), 0.05);

    pObj = vec3(pRoad.x - 4.1, pRoad.y - 0.8, 0.);
    len = max(len, -Box3(pObj, vec3(0.1, 0.1, 0.1), 0.1));

    pObj = vec3(pRoad.x - 4.3, pRoad.y - 0.5, round(pRoad.z * 0.5) / 0.5 - pRoad.z);
    len = min(len, Box3(pObj, vec3(0.05, 0.5, 0.05), 0.01));

    float reflector = Box3(pObj - vec3(-0.1, 0.3, 0.0), vec3(0.04, 0.06, 0.03), 0.01);
    vec2 res = MinDist(vec2(len, MOTO_EXHAUST_ID), vec2(reflector, ROAD_REFLECTOR_ID));

    // street lamp
    pObj = vec3(pRoad.x - 4.5, pRoad.y - 1.5, round(pRoad.z / 30.) * 30. - pRoad.z);
    len = Box3(pObj, vec3(0.1, 3., 0.1), 0.1);
    res = MinDist(res, vec2(len, MOTO_EXHAUST_ID));

    pObj = vec3(pRoad.x - 4.3, pRoad.y - 4., pObj.z);
    len = Box3(pObj, vec3(0.2, 0.1, 0.1), 0.1);
    res = MinDist(res, vec2(len, MOTO_BREAK_LIGHT_ID)); // TODO: proper light

    return res;
}

vec2 terrainShape(vec3 p, vec4 splineUV)
{
    float heightToDistanceFactor = 0.75;

    // First, compute the smooth terrain
    float terrainHeight = smoothTerrainHeight(p.xz);
    float relativeHeight = p.y - terrainHeight;

    // If the distance is sufficiently large, stop there
    if (relativeHeight > 5.5)
    {
        return vec2(heightToDistanceFactor * relativeHeight, GROUND_ID);
    }

    // Compute the road presence
    float isRoad = 1.0 - smoothstep(roadWidthInMeters.x, roadWidthInMeters.y, abs(splineUV.x));

    // If (even partly) on the terrain, add detail to the terrain
    if (isRoad < 1.0)
    {
        terrainHeight += terrainDetailHeight(p.xz);
    }

    // If (even partly) on the road, flatten road
    float roadHeight = terrainHeight;
    if (isRoad > 0.0)
    {
        // Get the point on the center line of the spline
        vec2 positionOnSpline = GetPositionOnSpline(splineUV.yw);

        // Get the terrain height at the center line
        roadHeight = smoothTerrainHeight(positionOnSpline);
        float x = clamp(abs(splineUV.x / roadWidthInMeters.x), 0., 1.);
        roadHeight += 0.2 * (1. - x * x * x);
    }

    // Combine terrain height and road heigt
    float height = mix(terrainHeight, roadHeight, isRoad);

    relativeHeight = p.y - height;
    
    vec2 d = vec2(heightToDistanceFactor * relativeHeight, GROUND_ID);

    d = MinDist(d, roadSideItems(splineUV, p.y - roadHeight));
    return d;
}

float tree(vec3 globalP, vec3 localP, vec2 id, vec4 splineUV, float current_t) {
    float h1 = hash21(id);
    float h2 = hash11(h1);

    // Define if the area has trees
    float presence = smoothstep(-0.7, 0.7, fBm(id / 500., 2, 0.5, 0.3));
    if (h1 < presence)
    {
        return INF;
    }

    // Clear trees close to the road
    if (abs(splineUV.x) < roadWidthInMeters.y) return INF;

    //
    // FIXME: the splineUV is relative to the current position, not relative
    // to the tree position.
    // This will probably need some coordinate trickery to know if there is
    // a tree or not.
    // But if that doesn't work, we can still use splineUV to ignore cases in
    // which we are sure there is or there is no tree. Then for cases in
    // between, we can evaluate the spline relative to the tree position.
    // That should still be a lot fewer spline evaluations.
    //

    float treeHeight = mix(5., 20., 1.-h1*h1);
    float treeWidth = treeHeight * mix(0.3, 0.5, h2*h2);
    float terrainHeight = smoothTerrainHeight(id);

    localP.y -= terrainHeight + 0.5 * treeHeight;
    localP.xz += (vec2(h1, h2)*2. - 1.) * 2.;

    float d = Ellipsoid(localP, 0.5*vec3(treeWidth, treeHeight, treeWidth));

    float leaves = 1. - smoothstep(50., 200., current_t);
    if (d < 2. && leaves > 0.)
    {
        d += leaves * fBm(5. * vec2(2.*atan(localP.z, localP.x), localP.y) + id, 2, 0.5, 0.5) * 0.5;
    }

    return d;
}

vec2 treesShape(vec3 p, vec4 splineUV, float current_t)
{
    float spacing = 10.;

    // iq - repeated_ONLY_SYMMETRIC_SDFS (https://iquilezles.org/articles/sdfrepetition/)
    //vec3 lim = vec3(1e8,0,1e8);
    vec2 id = round(p.xz / spacing) * spacing;
    vec3 localP = p;
    localP.xz -= id;
    return vec2(tree(p, localP, id, splineUV, current_t), GROUND_ID);
}
